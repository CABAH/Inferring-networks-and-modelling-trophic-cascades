#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov 20 09:29:12 2020

@author: giovanni strona
"""
import csv
from igraph import Graph
from random import sample,randrange,random
from numpy import array,where,inf,mean
from numpy.random import lognormal


all_sp_18,all_sp_80 = set([]),set([])
for i in range(1,1001):
	f18 = [j for j in csv.reader(open('./nets_18/'+str(i)+'.csv','r'))]
	f80 =[j for j in csv.reader(open('./nets_80_ok/'+str(i)+'.csv','r'))]
	for j in f18[1:]:
		all_sp_18 |= set(j[1:])
	for j in f80[1:]:
		all_sp_80 |= set(j[1:])
	print (i)


ext_spp = all_sp_80-all_sp_18

ext_dict=dict()
for i in all_sp_80:
	if i in ext_spp:
		ext_dict[i] = 1
	else:
		ext_dict[i] = 0

########Analytical risk
net_n = 1
f80 = [j for j in csv.reader(open('./nets_80_ok/'+str(net_n)+'.csv','r'))]
net = [i[1:][::-1] for i in f80[1:]]
g = Graph.TupleList(net,directed=True)
spp = g.vs['name']
def p_ext(l):
	p = 1
	for i in l:
		p *= i
	return p



all_paths = g.get_shortest_paths('plants',spp,mode='OUT')
len(g.vs)
len(all_paths)


tl = []
for t_sp in range(len(g.vs)):
	#tp_all = g.shortest_paths_dijkstra(p_set_ok,t_sp)
	row = []
	for p_sp in ['plants']:
		rg = g.copy()
		tp = rg.get_shortest_paths(p_sp,t_sp)[0]
		while len(tp)>1:
			ttl = len(tp)
			row.append(ttl)
			rg.delete_edges([tuple(tp[-2:])])
			tp = rg.get_shortest_paths(p_sp,t_sp,mode='OUT')[0]
	if row!=[]:
		tl.append([mean(row),min(row),max(row)])
	else:
		tl.append([1,1,1])
	print (g.vs['name'][t_sp],tl[-1])



tl_dict = dict([[g.vs['name'][i],tl[i]] for i in range(len(g.vs))])


#########RESAVE NETWORKS
#####coextinction
#for net_n in range(1,1001):
#	p_set = ['p'+str(i) for i in range(1440)]
#	i_set = ['i'+str(i) for i in range(5620)]
#	f_set = ['f'+str(i) for i in range(104)]
#	comp_net = list(csv.reader(open('./networks/'+str(net_n)+'.csv','r')))
#	g = Graph.TupleList(comp_net,directed=True)
#	#g.es['weight'] = sample(list(lll),len(g.es))
#	g.delete_vertices(['plants','invertebrates','FishInv'])
#	plants = sorted(list(set(p_set)&set(g.vs['name'])))
#	non_plants = [i for i in g.vs['name'] if i not in plants]
#	ddd = g.shortest_paths_dijkstra(non_plants,plants, mode="IN")
#	to_keep = [non_plants[i] for i in range(len(non_plants)) if min(ddd[i])!=inf]+plants
#	g = g.subgraph(to_keep)	#reduce the graph to only species having a path connecting them to basal resources
#	g = g.simplify()	#eliminate duplicate edges
#	out_net = open('./networks_simp/'+str(net_n)+'.csv','w')
#	names = g.vs['name']
#	for i in g.es:
#		v1,v2 = i.tuple
#		out_net.write(','.join(map(str,[names[v1],names[v2]]))+'\n')
#	out_net.close()
#	print (net_n)
#
#
############



####coextinction
out = open('results_21_09.csv','w')
out.write('net_n,extinct_status,species,vulnerability,mean_tl,min_tl,max_tl,sigma_p,sigma_i,sigma_f,conn_ip,tre\n')
for net_n in range(1,1001):
	f80 = [j for j in csv.reader(open('./nets_80_ok/'+str(net_n)+'.csv','r'))]
	net = [i[1:][::-1] for i in f80[1:]]
	sigma_p = randrange(5,16)/10.0
	sigma_i = randrange(5,16)/10.0
	sigma_f = randrange(5,16)/10.0
	p_set = ['p'+str(i) for i in range(1440) for j in range(1+int(round(lognormal(sigma=sigma_p))))]
	i_set = ['i'+str(i) for i in range(5620) for j in range(1+int(round(lognormal(sigma=sigma_i))))]
	f_set = ['f'+str(i) for i in range(104) for j in range(1+int(round(lognormal(sigma=sigma_f))))]
	#create links between vertebrates and plants/invertebrates
	comp_net = []
	for i in net:
		res,cons = i
		if cons not in ['plants','invertebrates','FishInv']:
			if res == 'plants':
				res = sample(p_set,1)[0]
			if res == 'invertebrates':# and random()<0.75:
				res = sample(i_set,1)[0]
			if res == 'FishInv':
				res = sample(f_set,1)[0]
		comp_net.append([res,cons])
	#create links between plants and invertebrates
	non_vert = set(p_set+f_set+i_set)
	conn_ip = random()/10.0 #structure is given by connectance and sigmas
	for i in range(int(len(set(p_set))*len(set(i_set))*conn_ip)):
		comp_net.append([sample(p_set,1)[0],sample(i_set,1)[0]])
	for i in range(int(len(set(p_set))*len(set(f_set))*conn_ip)):
		comp_net.append([sample(p_set,1)[0],sample(f_set,1)[0]])
	pres_nodes = set([j[1] for j in comp_net])
	for i in set(i_set):
		if i not in pres_nodes:
			comp_net.append([sample(p_set,1)[0],i])
	for i in set(f_set):
		if i not in [j[1] for j in comp_net]:
			comp_net.append([sample(p_set,1)[0],i])
	out_net = open('./networks/'+str(net_n)+'.csv','w')
	for i in comp_net:
		out_net.write(','.join(map(str,i))+'\n')
	out_net.close()
	g = Graph.TupleList(comp_net,directed=True)
	#g.es['weight'] = sample(list(lll),len(g.es))
	g.delete_vertices(['plants','invertebrates','FishInv'])
	plants = sorted(list(set(p_set)&set(g.vs['name'])))
	non_plants = [i for i in g.vs['name'] if i not in plants]
	ddd = g.shortest_paths_dijkstra(non_plants,plants, mode="IN")
	to_keep = [non_plants[i] for i in range(len(non_plants)) if min(ddd[i])!=inf]+plants
	g = g.subgraph(to_keep)	#reduce the graph to only species having a path connecting them to basal resources
	g = g.simplify()	#eliminate duplicate edges
	spp = g.vs['name']
	tre = random()
	vuln_dict = dict([[i,0.9] for i in range(len(g.vs))])
	nei_list = []
	for i in range(len(spp)):
		neis = g.neighbors(i,mode='IN')
		nei_list.append(neis)
		if spp[i] in set(i_set)|set(f_set):
			vuln_dict[i] = 0.9**int(round(len(neis)*tre))
	vert_id = [i for i in range(len(spp)) if spp[i] not in non_vert]
	it = 0
	stop = 'no'
	while stop == 'no':
		stop = 'yes'
		for i in vert_id:
			orig = vuln_dict[i]
			new = p_ext(sorted([vuln_dict[j] for j in nei_list[i]])[int(round(len(nei_list[i])*tre)):])
			#p_ext([vuln_dict[j] for j in nei_list[i]])
			if new!=orig:
				vuln_dict[i] = new
				stop = 'no'
		it+=1
	for i in range(len(g.vs)):
		if g.vs[i]['name'] in non_vert:
			pass
		else:
			out.write(','.join(map(str,[net_n,
									   ext_dict[g.vs[i]['name']],
									   g.vs[i]['name'],
									   vuln_dict[i]]+
										tl_dict[g.vs[i]['name']]+
										[sigma_p,sigma_i,sigma_f,conn_ip,tre	]
									))+'\n')
	print (net_n) #print network number to track progress in the analysis



out.close()


























